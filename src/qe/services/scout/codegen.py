"""LLM-powered code change generation for scout proposals."""

from __future__ import annotations

import logging

import instructor
import litellm
from pydantic import BaseModel, Field

from qe.models.scout import CodeChange, ImprovementIdea
from qe.runtime.feature_flags import get_flag_store

log = logging.getLogger(__name__)


class _FileChange(BaseModel):
    """A single file modification generated by the LLM."""

    file_path: str = Field(description="Relative path to the file")
    change_type: str = Field(description="create, modify, or delete")
    new_content: str = Field(default="", description="Full new content for create/modify")
    rationale: str = Field(default="", description="Why this change is needed")


class _CodeGenResult(BaseModel):
    """LLM-generated code changes for an improvement idea."""

    changes: list[_FileChange] = Field(default_factory=list)
    impact_assessment: str = Field(default="", description="Expected impact summary")
    risk_assessment: str = Field(default="", description="Potential risks")
    rollback_plan: str = Field(default="", description="How to safely revert")


class ScoutCodeGenerator:
    """Generate code changes from improvement ideas using LLM."""

    def __init__(self, model: str = "gpt-4o") -> None:
        self._model = model

    async def generate(
        self,
        idea: ImprovementIdea,
        file_contents: dict[str, str] | None = None,
    ) -> tuple[list[CodeChange], str, str, str]:
        """Generate code changes for an idea.

        Returns (changes, impact_assessment, risk_assessment, rollback_plan).
        """
        if not get_flag_store().is_enabled("innovation_scout"):
            return [], "", "", ""

        file_context = ""
        if file_contents:
            for path, content in file_contents.items():
                file_context += f"\n--- {path} ---\n{content[:2000]}\n"

        try:
            client = instructor.from_litellm(litellm.acompletion)
            result = await client.chat.completions.create(
                model=self._model,
                messages=[
                    {
                        "role": "system",
                        "content": (
                            "You are an expert Python developer. Generate precise code changes "
                            "to implement an improvement idea for the Question Engine codebase. "
                            "The codebase uses Python 3.14, FastAPI, Pydantic v2, aiosqlite, "
                            "litellm, instructor. Follow existing patterns. "
                            "Provide complete file contents for new files and modified files. "
                            "Be conservative â€” make minimal changes that achieve the goal."
                        ),
                    },
                    {
                        "role": "user",
                        "content": (
                            f"Improvement: {idea.title}\n"
                            f"Description: {idea.description}\n"
                            f"Category: {idea.category}\n"
                            f"Rationale: {idea.rationale}\n"
                            f"Affected files: {', '.join(idea.affected_files)}\n"
                            f"\nExisting file contents:{file_context or ' (not available)'}"
                        ),
                    },
                ],
                response_model=_CodeGenResult,
            )
        except Exception:
            log.exception("scout.codegen_failed idea=%s", idea.idea_id)
            return [], "", "", ""

        changes: list[CodeChange] = []
        for fc in result.changes:
            valid = ("create", "modify", "delete")
            change_type = fc.change_type if fc.change_type in valid else "modify"
            changes.append(
                CodeChange(
                    file_path=fc.file_path,
                    change_type=change_type,
                    diff="",  # Diff populated after applying to worktree
                )
            )

        return (
            changes,
            result.impact_assessment,
            result.risk_assessment,
            result.rollback_plan,
        )

    async def read_affected_files(
        self, affected_files: list[str]
    ) -> dict[str, str]:
        """Read affected files for context. Returns {path: content}."""
        from qe.tools.file_ops import file_read

        contents: dict[str, str] = {}
        for path in affected_files:
            try:
                result = await file_read(path)
                contents[path] = result.get("content", "")
            except Exception:
                log.debug("scout.file_read_failed path=%s", path)
        return contents
